"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFiles = void 0;
const tslib_1 = require("tslib");
const matcher_1 = require("matcher");
const fs_1 = require("fs");
const path_1 = require("path");
const js_yaml_1 = require("js-yaml");
async function getFilesInDirectory(directory) {
    const allEntries = await fs_1.promises.readdir(directory, { withFileTypes: true });
    const files = [];
    const directories = [];
    allEntries.forEach((entry) => {
        if (entry.isFile()) {
            files.push(entry.name);
        }
        if (entry.isDirectory()) {
            directories.push(entry.name);
        }
    });
    return {
        files,
        directories,
    };
}
async function loadContent(path) {
    if (path.toLowerCase().endsWith('json')) {
        return require(path);
    }
    const fileContents = await fs_1.promises.readFile(path, 'utf8');
    if (path.toLowerCase().endsWith('yml') || path.toLowerCase().endsWith('yaml')) {
        return js_yaml_1.safeLoad(fileContents);
    }
    return fileContents;
}
function normalizePath(originalPath) {
    return originalPath.replace(/\\/g, '/');
}
async function accumulateFiles(result, currentDirectory, pathSoFar, filter, recursively = false) {
    var e_1, _a, e_2, _b;
    const resolvedDirectoryPath = path_1.resolve(pathSoFar, currentDirectory);
    const directoryEntries = await getFilesInDirectory(resolvedDirectoryPath);
    try {
        for (var _c = tslib_1.__asyncValues(directoryEntries.files), _d; _d = await _c.next(), !_d.done;) {
            const file = _d.value;
            const resolvedFullPath = path_1.resolve(resolvedDirectoryPath, file);
            if (filter(resolvedFullPath)) {
                const content = await loadContent(resolvedFullPath);
                result.push({
                    path: normalizePath(resolvedDirectoryPath),
                    name: file,
                    content,
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (recursively) {
        try {
            for (var _e = tslib_1.__asyncValues(directoryEntries.directories), _f; _f = await _e.next(), !_f.done;) {
                const directory = _f.value;
                await accumulateFiles(result, directory, resolvedDirectoryPath, filter, recursively);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
function resolveFilter(config) {
    if (config.filter instanceof Function) {
        return config.filter;
    }
    if (typeof config.filter === 'string') {
        const normalizedPattern = normalizePath(config.filter);
        return (file) => {
            return matcher_1.isMatch(normalizePath(file), normalizedPattern);
        };
    }
    return () => true;
}
async function loadFiles(config) {
    const result = [];
    const filter = resolveFilter(config);
    await accumulateFiles(result, config.rootDirectory, '', filter, config.recursively);
    return result;
}
exports.loadFiles = loadFiles;
//# sourceMappingURL=loader.js.map