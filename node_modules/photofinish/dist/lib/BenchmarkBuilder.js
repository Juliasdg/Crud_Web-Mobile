"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BenchmarkBuilder = void 0;
const util_1 = require("util");
const benchmarkExecutioner_1 = require("./internal/benchmarkExecutioner");
const nodeVersionUtils_1 = require("./internal/nodeVersionUtils");
class BenchmarkBuilder {
    constructor() {
        this._benchmarkName = 'Benchmark';
        this._benchmarkEntryName = 'Benchmark entry';
        this._warmupCycles = 1000;
        this._benchmarkCycles = 20000;
        this._benchmarkCycleSamples = 100;
    }
    benchmarkName(name) {
        this._benchmarkName = name;
        return this;
    }
    benchmarkEntryName(name) {
        this._benchmarkEntryName = name;
        return this;
    }
    benchmarkEntryVersion(version) {
        this._benchmarkEntryVersion = version;
        return this;
    }
    benchmarkLabel(label) {
        this._label = label;
        return this;
    }
    warmupCycles(warmupCycles) {
        this._warmupCycles = warmupCycles;
        return this;
    }
    benchmarkCycles(benchmarkCycles) {
        this._benchmarkCycles = benchmarkCycles;
        return this;
    }
    benchmarkCycleSamples(benchmarkCycleSamples) {
        this._benchmarkCycleSamples = benchmarkCycleSamples;
        return this;
    }
    functionUnderTest(functionUnderTest, isPromiseResultAllowed = false) {
        if (this._asyncFunctionUnderTest) {
            throw new Error('asyncFunctionUnderTest is already set, please only set one of asyncFunctionUnderTest and functionUnderTest');
        }
        const sanityCheckResult = functionUnderTest();
        if (!isPromiseResultAllowed && isPromise(sanityCheckResult)) {
            throw new Error(`Please use .asyncFunctionUnderTest() method for benchmarking async functions. If you are sure about what you are doing and don't want to await returned promise within benchmark, please set "isPromiseResultAllowed" parameter to true`);
        }
        this._functionUnderTest = functionUnderTest;
        return this;
    }
    asyncFunctionUnderTest(asyncFunctionUnderTest) {
        if (this._functionUnderTest) {
            throw new Error('functionUnderTest is already set, please only set one of asyncFunctionUnderTest and functionUnderTest');
        }
        this._asyncFunctionUnderTest = asyncFunctionUnderTest;
        return this;
    }
    build() {
        if (!this._asyncFunctionUnderTest && !this._functionUnderTest) {
            throw new Error('Either asyncFunctionUnderTest or functionUnderTest needs to bet set.');
        }
        const benchmark = {
            nodeVersion: nodeVersionUtils_1.nodeVersion,
            benchmarkName: this._benchmarkName,
            benchmarkEntryName: this._benchmarkEntryName,
            benchmarkEntryVersion: this._benchmarkEntryVersion,
            label: this._label,
            warmupCycles: this._warmupCycles,
            benchmarkCycles: this._benchmarkCycles,
            benchmarkCycleSamples: this._benchmarkCycleSamples,
            asyncFunctionUnderTest: this._asyncFunctionUnderTest,
            functionUnderTest: this._functionUnderTest,
            execute: () => {
                throw new Error('Function under test is asynchronous, use executeAsync() instead.');
            },
            executeAsync: () => {
                throw new Error('Function under test is synchronous, use execute() instead.');
            },
        };
        if (benchmark.functionUnderTest) {
            benchmark.execute = () => {
                return benchmarkExecutioner_1.executeBenchmarkSync(benchmark);
            };
        }
        if (benchmark.asyncFunctionUnderTest) {
            benchmark.executeAsync = () => {
                return benchmarkExecutioner_1.executeBenchmarkAsync(benchmark);
            };
        }
        return benchmark;
    }
}
exports.BenchmarkBuilder = BenchmarkBuilder;
function isPromise(value) {
    return util_1.types.isPromise(value);
}
//# sourceMappingURL=BenchmarkBuilder.js.map