"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeBenchmarkAsync = exports.executeBenchmarkSync = void 0;
const Measurement_1 = require("../Measurement");
const mathUtils_1 = require("./mathUtils");
async function warmupAsync(warmupCycles, functionUnderTest) {
    for (let i = 0; i < warmupCycles; i++) {
        await functionUnderTest();
    }
}
function warmup(warmupCycles, functionUnderTest) {
    for (let i = 0; i < warmupCycles; i++) {
        functionUnderTest();
    }
}
function processResults(benchmark, significantSamples) {
    const meanTime = mathUtils_1.calculateMean(significantSamples);
    return {
        benchmarkName: benchmark.benchmarkName,
        benchmarkEntryName: benchmark.benchmarkEntryName,
        benchmarkEntryVersion: benchmark.benchmarkEntryVersion,
        warmupCycles: benchmark.warmupCycles,
        benchmarkCycles: benchmark.benchmarkCycles,
        benchmarkCycleSamples: benchmark.benchmarkCycleSamples,
        label: benchmark.label,
        meanTime: new Measurement_1.Measurement(meanTime),
    };
}
function executeBenchmarkSync(benchmark) {
    warmup(benchmark.warmupCycles, benchmark.functionUnderTest);
    // Perform all cycles
    const significantSamples = [];
    for (let i = 0; i < benchmark.benchmarkCycles; i++) {
        // Perform full cycle
        const samples = [];
        for (let i = 0; i < benchmark.benchmarkCycleSamples; i++) {
            const hrStart = process.hrtime();
            benchmark.functionUnderTest();
            const hrEnd = process.hrtime(hrStart);
            const [, timeTakenInNanoSeconds] = hrEnd;
            samples.push(timeTakenInNanoSeconds);
        }
        const significantCycleSamples = mathUtils_1.filterSignificantSamples(samples);
        significantSamples.push(...significantCycleSamples);
    }
    return processResults(benchmark, significantSamples);
}
exports.executeBenchmarkSync = executeBenchmarkSync;
async function executeBenchmarkAsync(benchmark) {
    await warmupAsync(benchmark.warmupCycles, benchmark.asyncFunctionUnderTest);
    // Perform all cycles
    const significantSamples = [];
    for (let i = 0; i < benchmark.benchmarkCycles; i++) {
        // Perform full cycle
        const samples = [];
        for (let i = 0; i < benchmark.benchmarkCycleSamples; i++) {
            const hrStart = process.hrtime();
            await benchmark.asyncFunctionUnderTest();
            const hrEnd = process.hrtime(hrStart);
            const [, timeTakenInNanoSeconds] = hrEnd;
            samples.push(timeTakenInNanoSeconds);
        }
        const significantCycleSamples = mathUtils_1.filterSignificantSamples(samples);
        significantSamples.push(...significantCycleSamples);
    }
    return processResults(benchmark, significantSamples);
}
exports.executeBenchmarkAsync = executeBenchmarkAsync;
//# sourceMappingURL=benchmarkExecutioner.js.map