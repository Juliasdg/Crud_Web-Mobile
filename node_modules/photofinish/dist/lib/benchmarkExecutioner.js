"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeBenchmarkAsync = exports.executeBenchmarkSync = void 0;
const Measurement_1 = require("./Measurement");
const mathUtils_1 = require("./mathUtils");
async function warmupAsync(warmupCycles, functionUnderTest) {
    for (let i = 0; i < warmupCycles; i++) {
        await functionUnderTest();
    }
}
function warmup(warmupCycles, functionUnderTest) {
    for (let i = 0; i < warmupCycles; i++) {
        functionUnderTest();
    }
}
function executeBenchmarkSync(benchmark) {
    if (!benchmark.functionUnderTest) {
        throw new Error('Function under test is not set');
    }
    warmup(benchmark.warmupCycles, benchmark.functionUnderTest);
    // Perform all cycles
    const significantSamples = [];
    for (let i = 0; i < benchmark.benchmarkCycles; i++) {
        // Perform full cycle
        const samples = [];
        for (let i = 0; i < benchmark.benchmarkCycleSamples; i++) {
            const hrStart = process.hrtime();
            benchmark.functionUnderTest();
            const hrEnd = process.hrtime(hrStart);
            const [, timeTakenInNanoSeconds] = hrEnd;
            samples.push(timeTakenInNanoSeconds);
        }
        const significantCycleSamples = mathUtils_1.filterSignificantSamples(samples);
        significantSamples.push(...significantCycleSamples);
    }
    const meanTime = mathUtils_1.calculateMean(significantSamples);
    return {
        meanTime: new Measurement_1.Measurement(meanTime),
    };
}
exports.executeBenchmarkSync = executeBenchmarkSync;
async function executeBenchmarkAsync(benchmark) {
    if (!benchmark.asyncFunctionUnderTest) {
        throw new Error('Async function under test is not set');
    }
    await warmupAsync(benchmark.warmupCycles, benchmark.asyncFunctionUnderTest);
    // Perform all cycles
    const significantSamples = [];
    for (let i = 0; i < benchmark.benchmarkCycles; i++) {
        // Perform full cycle
        const samples = [];
        for (let i = 0; i < benchmark.benchmarkCycleSamples; i++) {
            const hrStart = process.hrtime();
            await benchmark.asyncFunctionUnderTest();
            const hrEnd = process.hrtime(hrStart);
            const [, timeTakenInNanoSeconds] = hrEnd;
            samples.push(timeTakenInNanoSeconds);
        }
        const significantCycleSamples = mathUtils_1.filterSignificantSamples(samples);
        significantSamples.push(...significantCycleSamples);
    }
    const meanTime = mathUtils_1.calculateMean(significantSamples);
    return {
        meanTime: new Measurement_1.Measurement(meanTime),
    };
}
exports.executeBenchmarkAsync = executeBenchmarkAsync;
//# sourceMappingURL=benchmarkExecutioner.js.map